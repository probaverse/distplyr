---
title: "Intro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This package attempts to solve the following issues. I'm not entirely able to articulate the package purpose at this time, but I imagine this will come in time as the package is developed.

- Bundle properties of a distribution (cdf, pdf/pmf, mean, variance, etc.) together with a single object, instead of them lying separate.
- Provide a more complete list of parametric families of distributions than comes with base R, with a clear specification of parameters and the type of distribution (if there's more than one, as in the negative binomial case). 
- Expand functionality of empirical distributions
- Allow the user to create their own distributions. (??)
- Modify a distribution by splicing or transforming.
- Provide an infrastructure for computing quantities that are not specified in base R, like means and variances; but also to compute missing quantities like cdf's or quantile functions, depending on what's missing.

```{r}
library(magrittr)
library(distplyr)
```


## Making a Distribution

Access a distribution from a parametric family using `dst_*()` functions. Make a Uniform(2, 3) distribution:

```{r}
dist1 <- dst_unif(2, 3)
```

Or, a GPD:

```{r}
dist2 <- dst_gpd(loc = 0, scale = 1, shape = 1)
```

You can make an empirical distribution from data as well:

```{r}
dist3 <- dst_emp(iris$Sepal.Length)
```

A degenerate distribution is still valid, and can be specified directly, or as a result of parameter boundaries:

```{r}
dist4 <- dst_norm(mean = 5, variance = 0)
dist5 <- dst_degen(5)
identical(dist4, dist5)
```

## Evaluating a Distribution

Means are easy to find -- no more looking up formulas:

```{r}
mean(dist1)
```

So are variances, skewnesses, etc:

```{r}
variance(dist1)
skewness(dist1)
```

Empirical distributions get the royal treatment, too:

```{r}
mean(dist3)
identical(mean(dist3), mean(iris$Sepal.Length))
```

## Distribution-related functions

Evaluating distribution-related functions, such as cdf, density, etc. can be accessed using the `fun_*()` family of functions.

Generate some data:

```{r}
rand_sepal_lengths <- fun_rand(dist3, 10)
length(rand_sepal_lengths)
```

Density/pmf -- or just "probability function" -- evaluated at some points:

```{r}
fun_prob(dist2, at = 2.5) # Density
fun_prob(dist3, at = rand_sepal_lengths) # pmf
```

If you want the actual function, don't specify `at`:

```{r, fig.width=8, fig.height=3, fig.align="center"}
cdf <- fun_cumu(dist3)
curve(cdf, 4, 8, n = 501)
```


PERHAPS CHANGE TO (so that the output is less "magic")

```{r}
eval_cumu(dist3, at = 2.5)
get_cumu(dist3)
```

## Manipulate distributions

You can `shift_left()` or `shift_right()` (or just `shift()`), or `scale_divide()` or `scale_multiply()`.

```{r}
dist1 %>% 
	shift_left(by = 1) %>% 
	scale_divide(by = 0.5)
```

## Grafting

Graft a GPD onto an empirical cdf:

```{r}
new <- dist3 %>%
	right_connect(dst_gpd(loc = 6, scale = 1, shape = 0.5), sep_x = 6)
```

```{r}
cdf <- fun_cumu(new)
curve(cdf, 4, 9, n = 1001)
```


## MLE?

```{r}
fam <- function(a, b) 
	dst_unif(a, b) %>% 
	get_nllh(data = iris$Sepal.Length)
	

dist3 %>% 
	get_nllh(data = ...)

nllh(~ Sepal.Length, data = iris, families = c("unif", "norm"))
```



