test_that("Only continuous distributions and positive scales allowed.", {
  expect_error(scale_hazard(dst_norm(0, 1), by = 0))
  expect_error(scale_hazard(dst_norm(0, 1), by = -0.6))
  d <- dst_pois(1)
  expect_true(inherits(scale_hazard(d, 2), "dst_null"))
  d2 <- mix(d, dst_norm(0, 1))
  expect_true(inherits(scale_hazard(d2, 2), "dst_null"))
  expect_true(inherits(scale_hazard(dst_null(), 2), "dst_null"))
  # Even when scaling by 1
  expect_true(inherits(scale_hazard(d, 1), "dst_null"))
  expect_true(inherits(scale_hazard(d2, 1), "dst_null"))
})

test_that("Scaling by 1 gets the original distribution", {
  d1 <- dst_norm(0, 1)
  d2 <- dst_gpd(0, 1, 1)
  d3 <- dst_beta(2, 5)
  expect_identical(scale_hazard(d1, 1), d1)
  expect_identical(scale_hazard(d2, 1), d2)
  expect_identical(scale_hazard(d3, 1), d3)
})

test_that("Hazard functions are truly scaled: simple checks", {
  d1 <- dst_norm(0, 1)
  d2 <- dst_gpd(0, 1, 1)
  d3 <- dst_beta(2, 5)
  d1s <- scale_hazard(d1, 0.5)
  d2s <- scale_hazard(d2, 2)
  d3s <- scale_hazard(d3, 10)
  h1  <- eval_hazard(d1, at = -3:3)
  h2  <- eval_hazard(d2, at = 0:10)
  h3  <- eval_hazard(d3, at = 0:10 / 10)
  h1s <- eval_hazard(d1s, at = -3:3)
  h2s <- eval_hazard(d2s, at = 0:10)
  h3s <- eval_hazard(d3s, at = 0:10 / 10)
  expect_equal(0.5 * h1, h1s)
  expect_equal(2 * h2, h2s)
  expect_equal(10 * h3, h3s)
  H1  <- eval_chf(d1, at = -3:3)
  H2  <- eval_chf(d2, at = 0:10)
  H3  <- eval_chf(d3, at = 0:10 / 10)
  H1s <- eval_chf(d1s, at = -3:3)
  H2s <- eval_chf(d2s, at = 0:10)
  H3s <- eval_chf(d3s, at = 0:10 / 10)
  expect_equal(0.5 * H1, H1s)
  expect_equal(2   * H2, H2s)
  expect_equal(10  * H3, H3s)
  expect_true(median(d1s) > median(d1))
  expect_true(median(d2s) < median(d2))
  expect_true(median(d3s) < median(d3))
})

test_that("Representations calculated computationally match analytical soln.", {
  d <- scale_hazard(dst_norm(0, 2), 2.5)
  h <- function(x) eval_hazard(d, at = x)
  H <- Vectorize(function(x) integrate(h, -Inf, x)$value)
  x <- -5:5
  expect_equal(eval_chf(d, at = x), H(x))
  Sx <- exp(-H(x))
  expect_equal(eval_survival(d, at = x), Sx)
  expect_equal(eval_density(d, at = x), eval_hazard(d, at = x) * Sx)
  tau <- 1:9 / 10
  Qcomp <- distionary:::eval_quantile.dst(d, at = tau)
  expect_equal(eval_quantile(d, at = tau), Qcomp)
  expect_equal(eval_cdf(d, at = x), 1 - Sx)
})
